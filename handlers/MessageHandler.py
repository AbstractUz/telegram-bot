import datetime

import aiogram.types
from aiogram import Bot, Dispatcher, F, Router
from aiogram.enums import ContentType
from aiogram.filters import CommandStart, Command
from aiogram.fsm.context import FSMContext
from aiogram.types import InlineKeyboardMarkup, InputMediaPhoto, BotCommand
from aiogram.utils.formatting import Text, Code, Bold
from aiogram.utils.media_group import MediaGroupBuilder
from aiohttp import web

import Config
from Config import ADMIN, TOKEN, CARD_NUMBER, GROUP_PHOTO, SINGLE_PHOTO
from database import Users, UserType, Orders
from database.Categories import CategoriesService
from database.CategoryType import CategoryTypeService
from database.Database import Database
from database.OrderPhotos import OrderPhotosService
from handlers import AdminRouters, ModeratorRouters
from handlers.States import OrderState, OrderPhotos, CancelOrder
from handlers.Translation import _
from handlers.keyboard import all_category_types, person_count, order_accept, instagram_button, \
    language_markup
from middleware.Middleware import Middleware, ModeratorMiddleware

app = web.Application()
bot = Bot(token=TOKEN)
dp = Dispatcher()
db = Database()

mod_route = Router()
mod_route.message.middleware.register(ModeratorMiddleware())
dp.sub_routers.append(mod_route)
dp.sub_routers.append(AdminRouters.route)
dp.update.middleware.register(Middleware())
dp.sub_routers.append(ModeratorRouters.router)
users_service = Users.UsersService()
user_type_service = UserType.UserTypeService()
orders_service = Orders.OrdersService()
order_photos_service = OrderPhotosService()
category_service = CategoriesService()
category_type_service = CategoryTypeService()

WEB_SERVER_HOST = Config.WEB_SERVER_HOST
# Port for incoming request from reverse proxy. Should be any available port
WEB_SERVER_PORT = Config.WEB_SERVER_PORT

# Path to webhook route, on which Telegram will send requests
WEBHOOK_PATH = Config.WEBHOOK_PATH
# Secret key to validate requests from Telegram (optional)
WEBHOOK_SECRET = Config.WEBHOOK_SECRET
# Base URL for webhook will be used to generate webhook URL for Telegram,
# in this example it is used public DNS with HTTPS support
BASE_WEBHOOK_URL = Config.BASE_WEBHOOK_URL


# TODO: User language instead of message.from_user.language_code
# TODO: Category type lang
# TODO: Add seperate price for many or single person
# TODO: 

@dp.message(
    Command('lang')
)
async def change_language(message: aiogram.types.Message) -> None:
    await select_language(message)


async def welcome_customer(user_id, message, lang):
    content = Text(
        Text(_("–£–≤–∞–∂–∞–µ–º—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å, –≤—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª–∏—Å—å –≤ –±–æ—Ç–µ Ismo Group.\n", lang)),
        Bold(_("–í–∞—à –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–æ–Ω–Ω—ã–π –Ω–æ–º–µ—Ä: ", lang)),
        Code(user_id),
        Text(
            _("\n–° –ø–æ–º–æ—â—å—é —ç—Ç–æ–≥–æ –±–æ—Ç–∞ –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–∫–∞—Ç—å –∏ —Å–∫–∞—á–∏–≤–∞—Ç—å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ —Å–æ —Å–≤–æ–µ–π —Å–≤–∞–¥—å–±—ã, –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è –∏–ª–∏ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è.",
              lang))
    )
    await message.answer(**content.as_kwargs())
    await message.answer(
        Bold(_("–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–∫–∞–∑, –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å —Å –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞ –∑–¥–∞–Ω–∏—è –Ω–∏–∂–µ. ", lang)).as_markdown(),
        reply_markup=all_category_types(lang, "order_"), parse_mode='MarkdownV2')


@dp.message(
    CommandStart()
)
async def command_start_handler(message: aiogram.types.Message, state: FSMContext, lang: str) -> None:
    user: dict = users_service.getById(message.from_user.id)
    if user is None:
        user_type = user_type_service.getAdminType() if message.from_user.id == ADMIN else user_type_service.getCustomerType()
        users_service.create(message.from_user.id, message.from_user.username,
                             message.from_user.language_code, user_type)
        await select_language(message)
        return

    user_type = user['user_type']
    if user_type == user_type_service.getCustomerType():
        await welcome_customer(message.from_user.id, message, lang)
        await state.set_state(OrderState.category_type)
    else:
        await AdminRouters.command_start_handler(message, lang)


async def select_language(message: aiogram.types.Message):
    await bot.send_message(chat_id=message.from_user.id,
                           text="üá∫üáø Iltimos tilni tanlang! \nüá∑üá∫ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫! \nüá∫üá∏ Please select a language!",
                           reply_markup=language_markup())


@dp.callback_query(
    F.data.startswith('lang')
)
async def choose_language(query: aiogram.types.CallbackQuery) -> None:
    lang = query.data.split('_')[-1]
    users_service.setLanguage(query.from_user.id, lang)
    await query.message.delete()
    await welcome_customer(query.from_user.id, query.message, lang)


@dp.callback_query(
    F.data.startswith('order_category_type')
)
async def order_category_type(query: aiogram.types.CallbackQuery, state: FSMContext, lang: str) -> None:
    category_type_id = int(query.data.split(':')[-1])
    await state.update_data(category_type_id=category_type_id)
    await state.set_state(OrderState.message_ids)
    message_ids = []
    for category in category_service.getByType(category_type_id):
        message_ids.append(
            (await bot.send_photo(chat_id=query.from_user.id, photo=category['photo_id'],
                                  reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                                      [aiogram.types.InlineKeyboardButton(
                                          text=f"{category['name']}",
                                          callback_data=f"order_category:{category['id']}")]
                                  ]
                                  )
                                  )
             ).message_id
        )
    await state.update_data(message_ids=message_ids)
    await state.set_state(OrderState.category)


@dp.callback_query(
    F.data.startswith('order_category')
)
async def order_category(query: aiogram.types.CallbackQuery, state: FSMContext, lang: str) -> None:
    category_id = int(query.data.split(':')[-1])
    await state.update_data(category_id=category_id)
    for message_id in (await state.get_data())['message_ids']:
        if message_id != query.message.message_id:
            await bot.delete_message(chat_id=query.from_user.id, message_id=message_id)
    await state.set_state(OrderState.ceremony_date)
    await query.message.answer(_("–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É —Ü–µ—Ä–µ–º–æ–Ω–∏–∏!\n–ù–∞–ø—Ä–∏–º–µ—Ä: (24.10.2024)", lang))


@dp.message(
    OrderState.ceremony_date
)
async def order_ceremony_date(message: aiogram.types.Message, state: FSMContext, lang: str) -> None:
    date_str = message.text.split('.')
    if len(date_str) != 3:
        await message.answer(_("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã!", lang))
        return
    try:
        date = datetime.datetime(int(date_str[2]), int(date_str[1]), int(date_str[0]))
        await state.update_data(ceremony_date=date)
        await state.set_state(OrderState.single_person)
        media_group = [
            InputMediaPhoto(media=GROUP_PHOTO),
            InputMediaPhoto(media=SINGLE_PHOTO)
        ]
        await bot.send_media_group(chat_id=message.from_user.id, media=media_group)
        await message.answer(**Bold(
            _("–ù–∞ –æ–¥–Ω–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞ –≤ –µ–¥–∏–Ω–æ–º —Ç–∞—Ä–∏—Ñ–µ –í–∞–º –±—É–¥–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∞ —Ç–æ–ª—å–∫–æ 1 —Å–¥–µ–ª–∞–Ω–Ω–∞—è –í–∞–º–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è. –ò –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ —Ç–∞—Ä–∏—Ñ–æ–≤ —Å–æ–¥–µ—Ä–∂–∞—Ç —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –ª—é–¥–µ–π, –∫–æ—Ç–æ—Ä—ã—Ö –≤—ã –æ—Ç–º–µ—Ç–∏–ª–∏, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –Ω–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–º –≤–∞–º–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏, –∏–ª–∏ –≤—Å–µ—Ö –ª—é–¥–µ–π –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏, –µ—Å–ª–∏ –≤—ã –Ω–µ –æ—Ç–º–µ—Ç–∏–ª–∏ –ª—é–¥–µ–π –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏!",
              lang)).as_kwargs(),
                             reply_markup=person_count(lang))
    except:
        await message.answer(_("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã!", lang))


@dp.callback_query(
    F.data.endswith('_person')
)
async def order_person_count(query: aiogram.types.CallbackQuery, state: FSMContext, lang: str) -> None:
    single = str(query.data.split('_')[0]) == "single"
    await state.update_data(single_person=single)
    await state.set_state(OrderState.photo_id)
    if not single:
        await query.message.answer(_("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–≤–æ—é —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é, –∫–∞–∫ –º–Ω–æ–≥–∏–µ!", lang))
    else:
        await query.message.answer(_("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–≤–æ—é —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∏–¥–Ω–æ –≤–∞—à–µ –ª–∏—Ü–æ.", lang))


@dp.message(
    OrderState.photo_id
)
async def order_photo_id(message: aiogram.types.Message, state: FSMContext, lang: str) -> None:
    if message.content_type is not ContentType.PHOTO:
        single = (await state.get_data())['single_person']
        if not single:
            await message.answer(_("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–≤–æ—é —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é, –∫–∞–∫ –º–Ω–æ–≥–∏–µ!", lang))
        else:
            await message.answer(_("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–≤–æ—é —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤–∏–¥–Ω–æ –≤–∞—à–µ –ª–∏—Ü–æ.", lang))
        return
    photo_id = message.photo[-1].file_id
    await state.update_data(photo_id=photo_id)
    await state.set_state(OrderState.cheque_id)
    data = await state.get_data()
    category = category_service.getById(data['category_id'])
    category_type = category_type_service.getById(category['category_type'])
    price = category_type['group_price'] if not data['single_person'] else category_type['single_price']
    content = Text(_("–°—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞–∫–∞–∑–∞: ", lang), Bold(price), Text(_(" —Å—É–º\n", lang)),
                   Text(_("–û–ø–ª–∞—Ç–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç—É: ", lang)), Code(CARD_NUMBER), Text(_("\n", lang)),
                   Bold(_("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —á–µ–∫ –æ–ø–ª–∞—Ç—ã!", lang)))
    await message.answer(**content.as_kwargs())


@dp.message(
    OrderState.cheque_id
)
async def order_cheque_id(message: aiogram.types.Message, state: FSMContext, lang: str) -> None:
    if message.content_type is not ContentType.PHOTO:
        await message.answer(_("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ!", lang))
        return
    cheque_id = message.photo[-1].file_id
    await state.update_data(cheque_id=cheque_id)
    data = await state.get_data()
    order = orders_service.create(message.from_user.id, data['category_id'], data['ceremony_date'],
                                  data['single_person'],
                                  data['photo_id'], data['cheque_id'])
    moderators = users_service.getAllByUserType(user_type_service.getModeratorType())
    for moderator in moderators:
        await bot.send_message(chat_id=moderator['id'],
                               text=_("–ù–æ–≤—ã–π –∑–∞–∫–∞–∑!\nID: ", lang) + f"{message.from_user.id}\n" + _("–ö–∞—Ç–µ–≥–æ—Ä–∏—è: ",
                                                                                                    lang) + f"{data['category_id']}\n" + _(
                                   "–î–∞—Ç–∞: ", lang) + f"{data['ceremony_date']}\n" + _("–û–¥–∏–Ω —á–µ–ª–æ–≤–µ–∫: ",
                                                                                      lang) + f"{data['single_person']}",
                               reply_markup=order_accept(order['id'], lang))
    await state.clear()
    await state.set_state(OrderPhotos.order_id)
    await message.answer(
        _("–ó–∞–∫–∞–∑ —É—Å–ø–µ—à–Ω–æ –æ—Ñ–æ—Ä–º–ª–µ–Ω! –ù–∞—à–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –æ—Ç–ø—Ä–∞–≤—è—Ç –≤–∞–º –≤–∞—à–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ.", lang))


@dp.callback_query(
    F.data.startswith('accept_order:')
)
async def accept_order(query: aiogram.types.CallbackQuery, state: FSMContext, lang: str) -> None:
    order_id = query.data.split(':')[-1]
    if orders_service.getById(order_id)['moderator_id'] is not None:
        await query.message.delete()
        return
    order_id = query.data.split(':')[-1]
    order = orders_service.setModeratorId(order_id, query.from_user.id)
    media = MediaGroupBuilder()
    media.add_photo(order['photo_id'])
    media.add_photo(order['cheque_id'])

    # please send the photos to the user
    await query.message.answer(_("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!", lang))
    await state.update_data(order_id=order_id)
    await state.set_state(OrderPhotos.photos)
    await query.message.delete()
    await bot.send_media_group(chat_id=query.from_user.id, media=media.build())


@dp.message(
    OrderPhotos.photos
)
async def order_photos(message: aiogram.types.Message, state: FSMContext, lang: str) -> None:
    data = await state.get_data()
    if message.content_type is ContentType.DOCUMENT or message.content_type is ContentType.PHOTO:
        file_id = message.photo[-1].file_id if message.content_type is ContentType.PHOTO else message.document.file_id
        await state.set_state(OrderPhotos.photos)
        order_photos_service.add_order_photo(data['order_id'], file_id, message.content_type)
        return
    elif message.text == "/cancel":
        user = users_service.getById(message.from_user.id)
        if user['user_type'] != user_type_service.getModeratorType():
            return
        data = await state.get_data()
        if data is None:
            print("data none")
            return
        if data['order_id'] is not None:
            await state.clear()
            await state.set_state(CancelOrder.order_id)
            await state.update_data(order_id=data['order_id'])
            await state.set_state(CancelOrder.reason)
            await message.answer(_("–í–≤–µ–¥–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –æ—Ç–º–µ–Ω—ã –∑–∞–∫–∞–∑–∞:", lang))
        return

    order = orders_service.completeOrder(data['order_id'])

    for msg in order_photos_service.get_order_photos(order['id']):
        if msg['type'] == ContentType.PHOTO:
            await bot.send_photo(chat_id=order['user_id'], photo=msg['photo_id'])
        else:
            await bot.send_document(chat_id=order['user_id'], document=msg['photo_id'])
    await state.clear()

    await bot.send_message(chat_id=order['user_id'],
                           text=_("–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ, –º–æ–∂–µ—Ç–µ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –Ω–∞—à—É —Å—Ç—Ä–∞–Ω–∏—Ü—É –≤ –ò–Ω—Å—Ç–∞–≥—Ä–∞–º!", lang),
                           reply_markup=instagram_button(lang))
    await message.answer(_("–§–æ—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ!", lang))


async def send_error_message(message: aiogram.types.Message, error: Exception, lang: str) -> None:
    await message.answer(_(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {error}", lang))


@dp.message(
    CancelOrder.reason
)
async def cancel_order_reason(message: aiogram.types.Message, state: FSMContext, lang: str) -> None:
    data = await state.get_data()
    await state.clear()
    order = orders_service.getById(data['order_id'])
    await orders_service.cancelOrder(order['id'], message.text)
    await message.answer(_("–ó–∞–∫–∞–∑ –±—ã–ª –æ—Ç–º–µ–Ω–µ–Ω!", lang))
    await bot.send_message(chat_id=order['user_id'], text=_("–í–∞—à –∑–∞–∫–∞–∑ –±—ã–ª –æ—Ç–º–µ–Ω–µ–Ω –ø–æ –ø—Ä–∏—á–∏–Ω–µ: ", lang) + message.text)


@mod_route.message(
    Command('orders')
)
async def orders(message: aiogram.types.Message, lang: str) -> None:
    orders = orders_service.getByStatus(Orders.OrderStatus.PENDING)
    if len(orders) == 0:
        await message.answer(_("–ù–µ—Ç –∑–∞–∫–∞–∑–æ–≤!", lang))
        return
    for order in orders:
        category = category_service.getById(order['category_id'])
        category_type = category_type_service.getById(category['category_type'])
        price = category_type['group_price'] if not order['single_person'] else category_type['single_price']
        await message.answer(text=_("ID: ", lang) + f"{order['id']}\n" + _("–ö–∞—Ç–µ–≥–æ—Ä–∏—è: ", lang) + f"{category['name']}\n" + _("–î–∞—Ç–∞: ", lang) + f"{order['ceremony_date']}\n" + _("–û–¥–∏–Ω —á–µ–ª–æ–≤–µ–∫: ", lang) + f"{order['single_person']}\n" + _("Price: ", lang) + f"{price}\n",
            reply_markup=order_accept(order['id'], lang))


async def start_bot(bot: Bot):
    # await bot.set_webhook(f"{BASE_WEBHOOK_URL}{WEBHOOK_PATH}", secret_token=WEBHOOK_SECRET)
    await bot.delete_webhook()
    await bot.set_my_commands([BotCommand(command="/start", description="Botni boshlash"), BotCommand(command="/lang", description="Tilni o'zgartirish"), BotCommand(command="/help", description="Yordam olish")], language_code='uz')
    await bot.send_message(ADMIN, text=_("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω —É—Å–ø–µ—à–Ω–æ!", 'ru'))


async def stop_bot(bot: bot):
    await bot.send_message(ADMIN, text=_("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–∏–ª —Å–≤–æ—é —Ä–∞–±–æ—Ç—É!", 'ru'))


async def main() -> None:

    dp.startup.register(start_bot)
    dp.shutdown.register(stop_bot)
    await dp.start_polling(bot)


